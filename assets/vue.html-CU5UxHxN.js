import{_ as a,c as i,d as e,e as n,b as o,g as t,o as r}from"./app-Ciqs_Xc9.js";const m={};function d(v,l){return r(),i("div",null,[l[0]||(l[0]=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"Vue"),e("p",null,[t("Vue子组件调用父组件的方法"),e("br"),t(" 子组件调用父组件方法"),e("br"),t(" 路由传参"),e("br"),t(" 什么是mvvm? mvvm和mvc区别"),e("br"),t(" vue的优点是什么? ......")])],-1)),n(" more "),l[1]||(l[1]=o('<h2 id="vue子组件调用父组件的方法" tabindex="-1"><a class="header-anchor" href="#vue子组件调用父组件的方法"><span>Vue子组件调用父组件的方法</span></a></h2><ul><li>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法</li><li>第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了</li><li>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</li></ul><h3 id="子组件调用父组件方法" tabindex="-1"><a class="header-anchor" href="#子组件调用父组件方法"><span>子组件调用父组件方法</span></a></h3><p>用ref标识子组件,this.$refs.mychild.parentHandleclick(&quot;嘿嘿嘿&quot;)；</p><h2 id="路由传参" tabindex="-1"><a class="header-anchor" href="#路由传参"><span>路由传参</span></a></h2><ul><li>query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.- - query.name和this.$route.params.name</li></ul><h2 id="什么是mvvm" tabindex="-1"><a class="header-anchor" href="#什么是mvvm"><span>什么是mvvm</span></a></h2><ul><li><p>MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p></li><li><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p></li><li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p></li></ul><h2 id="mvvm和mvc区别" tabindex="-1"><a class="header-anchor" href="#mvvm和mvc区别"><span>mvvm和mvc区别</span></a></h2><ul><li>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到View 。</li></ul><h2 id="vue的优点是什么" tabindex="-1"><a class="header-anchor" href="#vue的优点是什么"><span>vue的优点是什么</span></a></h2><ul><li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li></ul><h2 id="你对vue生命周期的理解" tabindex="-1"><a class="header-anchor" href="#你对vue生命周期的理解"><span>你对vue生命周期的理解</span></a></h2><ul><li><p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p></li><li><p>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。</p></li><li><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p></li><li><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法。</p></li><li><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p></li></ul>',14))])}const p=a(m,[["render",d],["__file","vue.html.vue"]]),u=JSON.parse('{"path":"/other/html5/vue.html","title":"Vue知识点","lang":"zh-CN","frontmatter":{"title":"Vue知识点","date":"2020-08-07T14:44:26.000Z","tag":"Vue知识点","category":"Vue知识点","description":"Vue Vue子组件调用父组件的方法 子组件调用父组件方法 路由传参 什么是mvvm? mvvm和mvc区别 vue的优点是什么? ......","head":[["meta",{"property":"og:url","content":"https://www.songjun520.cn/other/html5/vue.html"}],["meta",{"property":"og:site_name","content":"Mr.Song"}],["meta",{"property":"og:title","content":"Vue知识点"}],["meta",{"property":"og:description","content":"Vue Vue子组件调用父组件的方法 子组件调用父组件方法 路由传参 什么是mvvm? mvvm和mvc区别 vue的优点是什么? ......"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-08-10T08:16:52.000Z"}],["meta",{"property":"article:tag","content":"Vue知识点"}],["meta",{"property":"article:published_time","content":"2020-08-07T14:44:26.000Z"}],["meta",{"property":"article:modified_time","content":"2022-08-10T08:16:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue知识点\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-08-07T14:44:26.000Z\\",\\"dateModified\\":\\"2022-08-10T08:16:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Song\\",\\"url\\":\\"https://www.songjun520.cn/\\"}]}"],["link",{"rel":"alternate","type":"application/atom+xml","href":"https://www.songjun520.cn/atom.xml","title":"Mr.Song Atom Feed"}],["link",{"rel":"alternate","type":"application/json","href":"https://www.songjun520.cn/feed.json","title":"Mr.Song JSON Feed"}],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://www.songjun520.cn/rss.xml","title":"Mr.Song RSS Feed"}]]},"headers":[{"level":2,"title":"Vue子组件调用父组件的方法","slug":"vue子组件调用父组件的方法","link":"#vue子组件调用父组件的方法","children":[{"level":3,"title":"子组件调用父组件方法","slug":"子组件调用父组件方法","link":"#子组件调用父组件方法","children":[]}]},{"level":2,"title":"路由传参","slug":"路由传参","link":"#路由传参","children":[]},{"level":2,"title":"什么是mvvm","slug":"什么是mvvm","link":"#什么是mvvm","children":[]},{"level":2,"title":"mvvm和mvc区别","slug":"mvvm和mvc区别","link":"#mvvm和mvc区别","children":[]},{"level":2,"title":"vue的优点是什么","slug":"vue的优点是什么","link":"#vue的优点是什么","children":[]},{"level":2,"title":"你对vue生命周期的理解","slug":"你对vue生命周期的理解","link":"#你对vue生命周期的理解","children":[]}],"git":{"createdTime":1659606751000,"updatedTime":1660119412000,"contributors":[{"name":"MrSong","email":"289097246@qq.com","commits":3}]},"readingTime":{"minutes":3.22,"words":966},"filePathRelative":"other/html5/vue.md","localizedDate":"2020年8月7日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">Vue</p>\\n<p>Vue子组件调用父组件的方法<br>\\n子组件调用父组件方法<br>\\n路由传参<br>\\n什么是mvvm?\\nmvvm和mvc区别<br>\\nvue的优点是什么?\\n......</p>\\n</div>\\n","autoDesc":true}');export{p as comp,u as data};

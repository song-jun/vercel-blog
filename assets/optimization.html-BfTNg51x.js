import{_ as p,c as a,b as t,o}from"./app-B-ayoO34.js";const r={};function l(n,e){return o(),a("div",null,e[0]||(e[0]=[t('<h2 id="webpack-的工作流程" tabindex="-1"><a class="header-anchor" href="#webpack-的工作流程"><span>Webpack 的工作流程</span></a></h2><p>Webpack 的工作流程可以概括为：初始化参数 -&gt; 创建 Compiler 对象 -&gt; 开始编译 -&gt; 模块加载和转换 -&gt; 递归构建依赖图 -&gt; 模块打包 -&gt; 输出文件。通过这个流程，Webpack 可以将多个模块打包成一个或多个文件，方便在浏览器中加载和运行。</p><h2 id="webpack-loader-解决具体问题" tabindex="-1"><a class="header-anchor" href="#webpack-loader-解决具体问题"><span>webpack loader 解决具体问题</span></a></h2><ul><li><strong>处理 CSS</strong>：Webpack 的 CSS 加载器（如 <code>css-loader</code> 和 <code>style-loader</code>）可以将 CSS 文件中的样式提取出来，并将其应用于页面中。</li><li><strong>处理图片</strong>：Webpack 的图片加载器（如 <code>file-loader</code> 和 <code>url-loader</code>）可以将图片文件打包成 base64 格式的字符串，以减少网络请求。</li><li><strong>处理字体</strong>：Webpack 的字体加载器（如 <code>file-loader</code> 和 <code>url-loader</code>）使用 file-loader 或 url-loader 处理字体文件，将字体文件复制到输出目录，并返回字体文件的路径。</li><li><strong>处理 JavaScript</strong>：Webpack 的 JavaScript 加载器（如 <code>babel-loader</code>）可以将 ES6+ 的 JavaScript 代码转换为浏览器兼容的代码。</li><li><strong>处理 HTML</strong>：Webpack 的 HTML 加载器（如 <code>html-loader</code>）可以将 HTML 文件中的图片、字体等资源进行打包处理。</li><li><strong>处理其他资源</strong>：Webpack 的其他加载器可以处理其他类型的资源，如 JSON、CSV 等。</li></ul><h2 id="webpack和vite" tabindex="-1"><a class="header-anchor" href="#webpack和vite"><span>Webpack和Vite</span></a></h2><p><strong>设计理念</strong></p><ul><li><strong>Webpack</strong>：秉持“一切皆模块”的理念，它会将项目中的所有资源（如 JavaScript、CSS、图片等）都视为模块，通过一系列的 loader 和 plugin 对这些模块进行处理和打包，最终生成可在浏览器中运行的静态文件。</li><li><strong>Vite</strong>：利用现代浏览器对 ES 模块（ES Modules）的原生支持，在开发环境下直接以原生 ES 模块的方式提供源码，只有在生产环境才进行打包优化，减少了开发阶段不必要的打包过程，从而提升开发效率。</li></ul><p><strong>构建速度</strong></p><ul><li><strong>Webpack</strong>：在启动开发服务器和热更新时，需要对整个项目进行完整的打包和编译，对于大型项目来说，这个过程可能会比较耗时，尤其是在项目文件较多、依赖复杂的情况下，构建速度会明显变慢。</li><li><strong>Vite</strong>：开发服务器启动速度极快，几乎可以瞬间启动。在进行模块热更新（HMR）时，Vite 只会重新加载被修改的模块，而不需要重新打包整个项目，因此热更新的响应速度非常快，几乎感觉不到延迟。</li></ul><p><strong>模块处理</strong></p><ul><li><strong>Webpack</strong>：拥有自己的模块解析系统，会对项目中的所有模块进行分析、转换和合并，最终将它们打包成一个或多个 bundle 文件。在处理模块时，Webpack 会根据配置的 loader 对不同类型的文件进行处理，例如使用 <code>babel-loader</code> 处理 JavaScript 文件，使用 <code>css-loader</code> 和 <code>style-loader</code> 处理 CSS 文件。</li><li><strong>Vite</strong>：在开发阶段不进行模块打包，而是让浏览器直接加载原生 ES 模块。当浏览器请求某个模块时，Vite 会按需对该模块进行编译和转换。在生产环境下，Vite 会使用 Rollup 进行打包，对代码进行优化和压缩。</li></ul><p><strong>配置复杂度</strong></p><ul><li><strong>Webpack</strong>：配置相对复杂，需要对各种 loader 和 plugin 有深入的了解。对于不同的项目需求，可能需要编写大量的配置代码来实现特定的功能，如代码分割、资源优化、环境变量配置等。对于初学者来说，学习和配置 Webpack 可能会有一定的难度。</li><li><strong>Vite</strong>：配置相对简单，默认提供了很多合理的配置选项，能够满足大多数项目的基本需求。对于一些简单的项目，甚至可以零配置启动。同时，Vite 的配置文件采用 JavaScript 编写，易于理解和修改。</li></ul><p><strong>插件生态</strong></p><ul><li><strong>Webpack</strong>：拥有庞大而成熟的插件生态系统，几乎可以找到解决任何构建问题的插件。这些插件可以帮助开发者实现各种功能，如代码压缩、文件处理、代码分割、性能优化等。然而，由于插件数量众多，选择合适的插件并进行正确的配置可能会比较困难。</li><li><strong>Vite</strong>：插件生态正在不断发展壮大，虽然目前还不如 Webpack 丰富，但已经能够满足大多数常见的开发需求。Vite 的插件开发相对简单，并且与 Rollup 插件有较好的兼容性，开发者可以复用一些 Rollup 插件。</li></ul><p><strong>适用场景</strong></p><ul><li><strong>Webpack</strong>：适用于大型、复杂的项目，尤其是对兼容性要求较高、需要进行深度优化和定制的项目。例如，一些传统的企业级应用、多页面应用等，Webpack 的强大功能和丰富的插件生态可以更好地满足这些项目的需求。</li><li><strong>Vite</strong>：更适合现代前端项目，特别是以 Vue、React 等框架为主的单页应用开发。对于追求快速开发体验、快速迭代的项目，Vite 的快速启动和热更新特性可以显著提高开发效率。同时，对于一些轻量级的项目和实验性项目，Vite 的简单配置和快速搭建能力也使其成为首选。</li></ul><h2 id="优化系列" tabindex="-1"><a class="header-anchor" href="#优化系列"><span>优化系列</span></a></h2><p>1、路由懒加载</p><p>⑴：Vue异步组件</p><ul><li><p>vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。</p></li><li><p>component: resolve =&gt; require([&#39;放入需要加载的路由地址&#39;], resolve)</p></li></ul><p>⑵：ES6标准语法import（）---------推荐使用！！！！！ const Foo = () =&gt; import(&#39;../components/Foo&#39;)</p><p>⑶：webpack的require.ensure()</p><p>2、keep-alive缓存页面</p><p>3、使用v-show复用DOM</p><p>4、v-for遍历避免同时使用v-if， 计算属性提前把数组进行过滤</p><p>5、长列表性能优化</p><p>如果列表纯粹是显示数据 不会有改变 数据就不需要响应式 , 使用freeze方法进行冻结，或者更改属性为false 如果是大数据列表，可以采用虚拟滚动，只渲染少部分区域内容</p><p>6、事件销毁</p><p>vue组件销毁时，会自动解绑他的全部指令及事件监听器，但仅限于组件本身的事件</p><p>7、图片懒加载</p><p>对于图片过多的页面 为了加速页面的加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片不做加载，等到滚动到可视区域之后再去加载</p><p>8、第三方插件按需导入</p><p>像element-ui这样的第三方组件库可以按需映入避免体积太大</p><p>9.子组件分割</p><p>子组件中有一些比较耗时的就单独分割成为一个组件，自己做自己的渲染，不会影响其他的组件</p><p>10、变量本地化</p><p>reault实际上是computed出来的属性 同时也是base的属性 base属性比较耗时</p><p>11、SSR</p><p>12、静态资源使用 CDN</p><p>13、使用字体图标 iconfont 代替图片图标</p><p>14、压缩文件</p><p>15、减少 ES6 转为 ES5 的冗余代码</p><p>16、减少重绘重排</p><h2 id="减少重绘回流" tabindex="-1"><a class="header-anchor" href="#减少重绘回流"><span>减少重绘回流</span></a></h2><h3 id="样式设置" tabindex="-1"><a class="header-anchor" href="#样式设置"><span>样式设置</span></a></h3><p>1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率</p><p>2、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次</p><p>3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流</p><p>4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流</p><p>5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间</p><p>6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现</p><h3 id="渲染层" tabindex="-1"><a class="header-anchor" href="#渲染层"><span>渲染层</span></a></h3><p>1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围</p><p>2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流</p><h3 id="dom优化" tabindex="-1"><a class="header-anchor" href="#dom优化"><span>DOM优化</span></a></h3><p>1、缓存DOM</p><p>const div = document.getElementById(&#39;div&#39;)</p><p>由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM</p><p>2、减少DOM深度及DOM数量</p><p>HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。</p><p>3、批量操作DOM</p><p>由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM</p><p>4、批量操作CSS样式</p><p>通过切换class或者使用元素的style.csstext属性去批量操作元素样式</p><p>5、在内存中操作DOM</p><p>使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上</p><p>6、DOM元素离线更新</p><p>对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作</p><p>7、DOM读写分离</p><p>浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行</p><p>8、事件代理</p><p>事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件</p><p>利用事件代理，可以减少内存使用，提高性能及降低代码复杂度</p><p>9、防抖和节流</p><p>使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发</p><p>10、及时清理环境</p><p>及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存</p>',78)]))}const s=p(r,[["render",l]]),c=JSON.parse('{"path":"/interview/optimization.html","title":"性能优化方法面试题","lang":"zh-CN","frontmatter":{"title":"性能优化方法面试题","date":"2020-08-07T14:24:00.000Z","category":"面试题","tag":"性能优化方法","feed":false,"seo":false,"head":[["link",{"rel":"alternate","type":"application/atom+xml","href":"https://www.songjun520.cn/atom.xml","title":"Mr.Song Atom Feed"}],["link",{"rel":"alternate","type":"application/json","href":"https://www.songjun520.cn/feed.json","title":"Mr.Song JSON Feed"}],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://www.songjun520.cn/rss.xml","title":"Mr.Song RSS Feed"}]]},"git":{"createdTime":1662690818000,"updatedTime":1741771205000,"contributors":[{"name":"MrSong","username":"MrSong","email":"289097246@qq.com","commits":4},{"name":"宋军","username":"宋军","email":"289097246@qq.com","commits":1},{"name":"君陌离","username":"君陌离","email":"289097246@qq.com","commits":2}]},"readingTime":{"minutes":9.16,"words":2748},"filePathRelative":"interview/optimization.md","localizedDate":"2020年8月7日"}');export{s as comp,c as data};
